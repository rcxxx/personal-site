---
id: rm-2019-armor
title: RoboMaster2019装甲识别
sidebar_label: RM2019自瞄
---
# 前言
随着RM比赛的发展，自瞄已经成为了各个队伍的标配，参加比赛开始就一直在做自瞄相关的工作，也有一些微不足道的经验总结下来，斗胆与大家分享。

## 目标分析
熟悉RM比赛都知道，比赛中很具有标志性是元素就是装甲板，弹丸击中装甲板后，机器人会根据相应的弹丸类型扣除相应的血量，血量扣完则表示机器人阵亡……

装甲板又分为大装甲和小装甲，可以通过它们的宽度来区分，如下图所示

大装甲与小装甲

两侧的白色部分是可以发光的灯条，比赛中一般呈红色光或是蓝色光，也有时会呈现紫色光

红色

蓝色

紫色


对于我们来说，最重要的就是尽可能多的击中对方的装甲板，
## 基本思路
发光的灯条，是否可以作为我们用来识别装甲板的特征呢，答案是肯定的
- 灯条作为特征来说，非常的易于捕捉，并且受到光线的影响相对于不发光的物体来说相对较小，并且在选择较低曝光时间的情况下，灯条相对于不发光物体的优势更加明显
- 并且灯条在一块装甲板上的相对位置是保持不变的，所以，我们只需要清楚灯条在图像上的变化规律，就能在图像中标记出灯条的位置，再通过换算，就能得出装甲板实际的位置

基本思路确定，直接开始！

- 基本思路总结
  1. 选择灯条作为主要特征
  2. 选择较低曝光时间利于提取灯条特征
  3. 找到灯条在图像中的变化规律定位灯条
  4. 将图象中的位置转换为实际位置

## 准备工作
基本思路已经有了，需要将其实现，则需要一些必须的设备
### 物资清单
| 名称   | 描述  |
|  --- | --- |
| 运算设备 | Intel Nuc 8i5bnk / Manifold 2 |
|  摄像头 | 工业相机 / 普通免驱摄像头，建议选择帧率较高，全局快门，曝光可调范围大的 |
|  通讯模块 | USB转TTL |

### 系统版本等
| 名称     | 版本           |
|----------|----------------|
| 操作系统 | Ubuntu18.04LTS |
| 语言     | C++、Python     |
| OpenCV   | 4.1.0          |
| Qt       | 5.12           |

## 代码实现

:::info 看这里
篇幅过长容易引起阅读不适，本文尽量只总结部分的处理，完整的项目代码可以参考这里👉
:::

### 预处理
两种思路
- HSV

``` cpp

```

这部分速率稍慢，当时做了一种优化方案，能够提高处理速度，思想可以参考

``` cpp

```

- RGB

RGB通道相减的这种处理办法速度快，也比较稳定

分离图像中的三个颜色通道

``` cpp
vector<Mat> v_split;     //B G R
split(src_img, v_split);
```

红蓝通道相减，再使用`threshold()`二值化

``` cpp {2,3}
subtract(_split[0], _split[2], bin_img_color);// b - r
/* ----如果是红色情况则相反---- */
// subtract(_split[2], _split[0], bin_img_color);// r - b
threshold(bin_img_color, bin_img_color, ARMOR_COLOR_TH, 255, THRESH_BINARY);
```

对灰度图像进行二值化，提取出图像中高亮的部分

``` cpp
cvtColor(roi_img, gray_img, COLOR_BGR2GRAY);
threshold(gray_img, bin_img_gray, ARMOR_GRAY_TH, 255, THRESH_BINARY);
```

对两个二值图进行 `与` 操作，提取同事满足颜色和高亮的部分，并存入bin_img中
``` cpp
bitwise_and(bin_img_color, bin_img_gray, bin_img);
```

基本已经能处理出图像中所有对应颜色的装甲板灯条，但是仍然会包括一些干扰项，后续拟合过程中再进行处理

### 拟合装甲板矩形
先将所有疑似灯条的部分都拟合为RotatedRect，筛选掉比例、角度不合适的灯条

``` cpp
RotatedRect R_rect = fitEllipse(contours[idx]);
float w_h_ratio = MIN(R_rect.size.width,R_rect.size.height) / MAX(R_rect.size.width,R_rect.size.height);
```

接下来就可以筛选矩形的形状，倾斜的角度等，筛选出较为合适的灯条，参数根据实际情况需要调整
``` cpp
if ((w_h_ratio < 0.4f)
&& ((0<= R_rect.angle && R_rect.angle<=45)||(135<=R_rect.angle && R_rect.angle<=180))){
    // code ...
}
```

每两个灯条之间都做匹配（成为组），筛选掉相距太远/太近
、高度差太大、相对位置不合适的组

``` cpp

```

避免两个灯条中间还有灯条（误识别大装甲）

``` cpp

```

避免侧面角度的伪装甲板
- 通过两个灯条矩形的旋转角度，可以分为内八和外八两种，视角由高到低，灯条会呈现不同的八字

``` cpp

```
### 角度解算
